<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Nonlinear · JuMP</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-44252521-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-44252521-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="JuMP logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="JuMP logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../should_i_use/">Should I use JuMP?</a></li><li><a class="tocitem" href="../../installation/">Installation Guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/getting_started/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/getting_started/getting_started_with_julia/">Getting started with Julia</a></li><li><a class="tocitem" href="../../tutorials/getting_started/getting_started_with_JuMP/">Getting started with JuMP</a></li><li><a class="tocitem" href="../../tutorials/getting_started/getting_started_with_sets_and_indexing/">Getting started with sets and indexing</a></li><li><a class="tocitem" href="../../tutorials/getting_started/getting_started_with_data_and_plotting/">Getting started with data and plotting</a></li><li><a class="tocitem" href="../../tutorials/getting_started/performance_tips/">Performance tips</a></li><li><a class="tocitem" href="../../tutorials/getting_started/design_patterns_for_larger_models/">Design patterns for larger models</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Linear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/linear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/linear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../tutorials/linear/diet/">The diet problem</a></li><li><a class="tocitem" href="../../tutorials/linear/cannery/">The cannery problem</a></li><li><a class="tocitem" href="../../tutorials/linear/facility_location/">The facility location problem</a></li><li><a class="tocitem" href="../../tutorials/linear/factory_schedule/">The factory schedule example</a></li><li><a class="tocitem" href="../../tutorials/linear/finance/">Financial modeling problems</a></li><li><a class="tocitem" href="../../tutorials/linear/geographic_clustering/">Geographical clustering</a></li><li><a class="tocitem" href="../../tutorials/linear/knapsack/">The knapsack problem</a></li><li><a class="tocitem" href="../../tutorials/linear/multi/">The multi-commodity flow problem</a></li><li><a class="tocitem" href="../../tutorials/linear/n-queens/">N-Queens</a></li><li><a class="tocitem" href="../../tutorials/linear/network_flows/">Network flow problems</a></li><li><a class="tocitem" href="../../tutorials/linear/prod/">The workforce scheduling problem</a></li><li><a class="tocitem" href="../../tutorials/linear/steelT3/">The SteelT3 problem</a></li><li><a class="tocitem" href="../../tutorials/linear/sudoku/">Sudoku</a></li><li><a class="tocitem" href="../../tutorials/linear/transp/">The transportation problem</a></li><li><a class="tocitem" href="../../tutorials/linear/urban_plan/">The urban planning problem</a></li><li><a class="tocitem" href="../../tutorials/linear/callbacks/">Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Nonlinear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/nonlinear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/portfolio/">Quadratic portfolio optimization</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/qcp/">Quadratically constrained programs</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/space_shuttle_reentry_trajectory/">Optimal control for a Space Shuttle reentry trajectory</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/rocket_control/">Rocket Control</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/rosenbrock/">The Rosenbrock function</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/mle/">Maximum likelihood estimation</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/clnlbeam/">The clnlbeam problem</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/querying_hessians/">Computing Hessians</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Conic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/conic/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/conic/start_values/">Primal and dual warm-starts</a></li><li><a class="tocitem" href="../../tutorials/conic/tips_and_tricks/">Tips and Tricks</a></li><li><a class="tocitem" href="../../tutorials/conic/logistic_regression/">Logistic regression</a></li><li><a class="tocitem" href="../../tutorials/conic/cluster/">K-means clustering via SDP</a></li><li><a class="tocitem" href="../../tutorials/conic/corr_sdp/">The correlation problem</a></li><li><a class="tocitem" href="../../tutorials/conic/experiment_design/">Experiment design</a></li><li><a class="tocitem" href="../../tutorials/conic/max_cut_sdp/">SDP relaxations: max-cut</a></li><li><a class="tocitem" href="../../tutorials/conic/min_distortion/">The minimum distortion problem</a></li><li><a class="tocitem" href="../../tutorials/conic/min_ellipse/">Minimum ellipses</a></li><li><a class="tocitem" href="../../tutorials/conic/robust_uncertainty/">Robust uncertainty sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/algorithms/benders_decomposition/">Benders decomposition</a></li><li><a class="tocitem" href="../../tutorials/algorithms/cutting_stock_column_generation/">Column generation</a></li><li><a class="tocitem" href="../../tutorials/algorithms/tsp_lazy_constraints/">Traveling Salesperson Problem</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/applications/power_systems/">Power Systems</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/models/">Models</a></li><li><a class="tocitem" href="../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../manual/expressions/">Expressions</a></li><li><a class="tocitem" href="../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../manual/containers/">Containers</a></li><li><a class="tocitem" href="../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../manual/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../manual/callbacks/">Solver-independent Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/models/">Models</a></li><li><a class="tocitem" href="../../reference/variables/">Variables</a></li><li><a class="tocitem" href="../../reference/expressions/">Expressions</a></li><li><a class="tocitem" href="../../reference/objectives/">Objectives</a></li><li><a class="tocitem" href="../../reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../reference/containers/">Containers</a></li><li><a class="tocitem" href="../../reference/solutions/">Solutions</a></li><li><a class="tocitem" href="../../reference/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../reference/extensions/">Extensions</a></li><li><a class="tocitem" href="../../reference/nonlinear/">Nonlinear Modeling</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Background Information</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/algebraic_modeling_languages/">Algebraic modeling languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../extensions/">Extensions</a></li><li class="is-active"><a class="tocitem" href>Nonlinear</a><ul class="internal"><li><a class="tocitem" href="#Standard-form"><span>Standard form</span></a></li><li><a class="tocitem" href="#API-overview"><span>API overview</span></a></li><li><a class="tocitem" href="#Expression-graph-representation"><span>Expression-graph representation</span></a></li><li><a class="tocitem" href="#ReverseAD"><span>ReverseAD</span></a></li></ul></li><li><a class="tocitem" href="../custom_solver_binaries/">Custom binaries</a></li><li><a class="tocitem" href="../style/">Style Guide</a></li><li><a class="tocitem" href="../roadmap/">Roadmap</a></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release notes</a></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">MathOptInterface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/">Introduction</a></li><li><a class="tocitem" href="../../moi/background/motivation/">Motivation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/tutorials/example/">Solving a problem using MathOptInterface</a></li><li><a class="tocitem" href="../../moi/tutorials/implementing/">Implementing a solver interface</a></li><li><a class="tocitem" href="../../moi/tutorials/mathprogbase/">Transitioning from MathProgBase</a></li><li><a class="tocitem" href="../../moi/tutorials/bridging_constraint/">Implementing a constraint bridge</a></li><li><a class="tocitem" href="../../moi/tutorials/manipulating_expressions/">Manipulating expressions</a></li><li><a class="tocitem" href="../../moi/tutorials/latency/">Latency</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-3" type="checkbox"/><label class="tocitem" for="menuitem-8-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/manual/standard_form/">Standard form problem</a></li><li><a class="tocitem" href="../../moi/manual/models/">Models</a></li><li><a class="tocitem" href="../../moi/manual/variables/">Variables</a></li><li><a class="tocitem" href="../../moi/manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../moi/manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../moi/manual/modification/">Problem modification</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-4" type="checkbox"/><label class="tocitem" for="menuitem-8-4"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/background/duality/">Duality</a></li><li><a class="tocitem" href="../../moi/background/infeasibility_certificates/">Infeasibility certificates</a></li><li><a class="tocitem" href="../../moi/background/naming_conventions/">Naming conventions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5" type="checkbox"/><label class="tocitem" for="menuitem-8-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/reference/standard_form/">Standard form</a></li><li><a class="tocitem" href="../../moi/reference/models/">Models</a></li><li><a class="tocitem" href="../../moi/reference/variables/">Variables</a></li><li><a class="tocitem" href="../../moi/reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../moi/reference/modification/">Modifications</a></li><li><a class="tocitem" href="../../moi/reference/nonlinear/">Nonlinear programming</a></li><li><a class="tocitem" href="../../moi/reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../moi/reference/errors/">Errors</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6" type="checkbox"/><label class="tocitem" for="menuitem-8-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-6-1" type="checkbox"/><label class="tocitem" for="menuitem-8-6-1"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Benchmarks/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Benchmarks/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-2" type="checkbox"/><label class="tocitem" for="menuitem-8-6-2"><span class="docs-label">Bridges</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Bridges/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Bridges/implementation/">Implementation</a></li><li><a class="tocitem" href="../../moi/submodules/Bridges/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-3" type="checkbox"/><label class="tocitem" for="menuitem-8-6-3"><span class="docs-label">FileFormats</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/FileFormats/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/FileFormats/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-4" type="checkbox"/><label class="tocitem" for="menuitem-8-6-4"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Utilities/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Utilities/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-5" type="checkbox"/><label class="tocitem" for="menuitem-8-6-5"><span class="docs-label">Test</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Test/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Test/reference/">API Reference</a></li></ul></li></ul></li><li><a class="tocitem" href="../../moi/release_notes/">Release notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer Docs</a></li><li class="is-active"><a href>Nonlinear</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Nonlinear</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/developers/nonlinear.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="nonlinear_developers"><a class="docs-heading-anchor" href="#nonlinear_developers">Nonlinear</a><a id="nonlinear_developers-1"></a><a class="docs-heading-anchor-permalink" href="#nonlinear_developers" title="Permalink"></a></h1><p>The <code>JuMP.Nonlinear</code> submodule contains data structures and functions for working with a nonlinear program in the form of an expression tree. This page explains the API and describes the rationale behind its design.</p><h2 id="Standard-form"><a class="docs-heading-anchor" href="#Standard-form">Standard form</a><a id="Standard-form-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-form" title="Permalink"></a></h2><p><a href="https://en.wikipedia.org/wiki/Nonlinear_programming">Nonlinear programs (NLPs)</a> are a class of optimization problems in which some of the constraints or the objective function are nonlinear:</p><p class="math-container">\[\begin{align}
    \min_{x \in \mathbb{R}^n} &amp; f_0(x) \\
    \;\;\text{s.t.} &amp; l_j \le f_j(x) \le u_j &amp; j = 1 \ldots m
\end{align}\]</p><p>There may be additional constraints, as well as things like variable bounds and integrality restrictions, but we do not consider them here because they are best dealt with by other components of JuMP and MathOptInterface.</p><h2 id="API-overview"><a class="docs-heading-anchor" href="#API-overview">API overview</a><a id="API-overview-1"></a><a class="docs-heading-anchor-permalink" href="#API-overview" title="Permalink"></a></h2><p>The core element of the <code>Nonlinear</code> submodule is <a href="../../reference/nonlinear/#JuMP.Nonlinear.NonlinearData"><code>Nonlinear.NonlinearData</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; import JuMP: Nonlinear

julia&gt; data = Nonlinear.NonlinearData()
NonlinearData with available features:
  * :ExprGraph</code></pre><p><a href="../../reference/nonlinear/#JuMP.Nonlinear.NonlinearData"><code>Nonlinear.NonlinearData</code></a> is a mutable struct that stores all of the nonlinear information added to the model.</p><h3 id="Decision-variables"><a class="docs-heading-anchor" href="#Decision-variables">Decision variables</a><a id="Decision-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Decision-variables" title="Permalink"></a></h3><p>Decision variables are represented by <a href="../../moi/reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a>s. The user is responsible for creating these.</p><h3 id="Nonlinear_Expressions"><a class="docs-heading-anchor" href="#Nonlinear_Expressions">Expressions</a><a id="Nonlinear_Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear_Expressions" title="Permalink"></a></h3><p>The input data-structure is a Julia <code>Expr</code>. The input expressions can incorporate <a href="../../moi/reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a>es, but these must be interpolated into the expression with <code>$</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; import JuMP: MOI

julia&gt; x = MOI.VariableIndex(1)
MathOptInterface.VariableIndex(1)

julia&gt; input = :(1 + sin($x)^2)
:(1 + sin(MathOptInterface.VariableIndex(1)) ^ 2)</code></pre><p>There are a number of restrictions on the input <code>Expr</code>:</p><ul><li>It cannot contain macros</li><li>It cannot contain broadcasting</li><li>It cannot contain splatting (except in limited situations)</li><li>It cannot contain linear algebra, such as matrix-vector products</li><li>It cannot contain generator expressions, including <code>sum(i for i in S)</code></li></ul><p>Given an input expression, add an expression using <a href="../../reference/nonlinear/#JuMP.Nonlinear.add_expression"><code>Nonlinear.add_expression</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; expr = Nonlinear.add_expression(data, input)
JuMP.Nonlinear.ExpressionIndex(1)</code></pre><p>The return value, <code>expr</code>, is a <a href="../../reference/nonlinear/#JuMP.Nonlinear.ExpressionIndex"><code>Nonlinear.ExpressionIndex</code></a> that can then be interpolated into other input expressions.</p><h3 id="Nonlinear_Parameters"><a class="docs-heading-anchor" href="#Nonlinear_Parameters">Parameters</a><a id="Nonlinear_Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear_Parameters" title="Permalink"></a></h3><p>In addition to constant literals like <code>1</code> or <code>1.23</code>, you can create parameters. Parameter are constants that you can change before passing the expression to the solver. Create a parameter using <a href="../../reference/nonlinear/#JuMP.Nonlinear.add_parameter"><code>Nonlinear.add_parameter</code></a>, which accepts a default value:</p><pre><code class="language-julia-repl hljs">julia&gt; p = Nonlinear.add_parameter(data, 1.23)
JuMP.Nonlinear.ParameterIndex(1)</code></pre><p>The return value, <code>p</code>, is a <a href="../../reference/nonlinear/#JuMP.Nonlinear.ParameterIndex"><code>Nonlinear.ParameterIndex</code></a> that can then be interpolated into other input expressions.</p><p>Update a parameter as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; data[p]
1.23

julia&gt; data[p] = 4.56
4.56

julia&gt; data[p]
4.56</code></pre><h3 id="Nonlinear_Objectives"><a class="docs-heading-anchor" href="#Nonlinear_Objectives">Objectives</a><a id="Nonlinear_Objectives-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear_Objectives" title="Permalink"></a></h3><p>Set a nonlinear objective using <a href="../../reference/nonlinear/#JuMP.Nonlinear.set_objective"><code>Nonlinear.set_objective</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; Nonlinear.set_objective(data, :($p + $expr + $x))</code></pre><h3 id="Nonlinear_Constraints"><a class="docs-heading-anchor" href="#Nonlinear_Constraints">Constraints</a><a id="Nonlinear_Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear_Constraints" title="Permalink"></a></h3><p>Add a constraint using <a href="../../reference/nonlinear/#JuMP.Nonlinear.add_constraint"><code>Nonlinear.add_constraint</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; c = Nonlinear.add_constraint(data, :(1 + sqrt($x) &lt;= 2.0))
JuMP.Nonlinear.ConstraintIndex(1)</code></pre><p>The return value, <code>c</code>, is a <a href="../../reference/nonlinear/#JuMP.Nonlinear.ConstraintIndex"><code>Nonlinear.ConstraintIndex</code></a> that is a unique identifier for the constraint. Interval constraints are also supported:</p><pre><code class="language-julia-repl hljs">julia&gt; c2 = Nonlinear.add_constraint(data, :(-1.0 &lt;= 1 + sqrt($x) &lt;= 2.0))
JuMP.Nonlinear.ConstraintIndex(2)</code></pre><p>Delete a constraint using <a href="../../reference/nonlinear/#JuMP.Nonlinear.delete"><code>Nonlinear.delete</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; Nonlinear.delete(data, c2)</code></pre><h3 id="User-defined-operators"><a class="docs-heading-anchor" href="#User-defined-operators">User-defined operators</a><a id="User-defined-operators-1"></a><a class="docs-heading-anchor-permalink" href="#User-defined-operators" title="Permalink"></a></h3><p>By default, <code>Nonlinear</code> supports a wide range of univariate and multivariate operators. However, you can also define your own operators by <em>registering</em> them.</p><h4 id="Univariate-operators"><a class="docs-heading-anchor" href="#Univariate-operators">Univariate operators</a><a id="Univariate-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate-operators" title="Permalink"></a></h4><p>Register a univariate user-defined operator using <a href="../../reference/nonlinear/#JuMP.Nonlinear.register_operator"><code>Nonlinear.register_operator</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; f(x) = 1 + sin(x)^2
f (generic function with 1 method)

julia&gt; Nonlinear.register_operator(data, :my_f, 1, f)</code></pre><p>Now, you can use <code>:my_f</code> in expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; new_expr = Nonlinear.add_expression(data, :(my_f($x + 1)))
JuMP.Nonlinear.ExpressionIndex(2)</code></pre><p>By default, <code>Nonlinear</code> will compute first- and second-derivatives of the registered operator using <code>ForwardDiff.jl</code>. Override this by passing functions which compute the respective derivative:</p><pre><code class="language-julia-repl hljs">julia&gt; f′(x) = 2 * sin(x) * cos(x)
f′ (generic function with 1 method)

julia&gt; Nonlinear.register_operator(data, :my_f2, 1, f, f′)</code></pre><p>or</p><pre><code class="language-julia-repl hljs">julia&gt; f′′(x) = 2 * (cos(x)^2 - sin(x)^2)
f′′ (generic function with 1 method)

julia&gt; Nonlinear.register_operator(data, :my_f3, 1, f, f′, f′′)</code></pre><h4 id="Multivariate-operators"><a class="docs-heading-anchor" href="#Multivariate-operators">Multivariate operators</a><a id="Multivariate-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-operators" title="Permalink"></a></h4><p>Register a multivariate user-defined operator using <a href="../../reference/nonlinear/#JuMP.Nonlinear.register_operator"><code>Nonlinear.register_operator</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; g(x...) = x[1]^2 + x[1] * x[2] + x[2]^2
g (generic function with 1 method)

julia&gt; Nonlinear.register_operator(data, :my_g, 2, g)</code></pre><p>Now, you can use <code>:my_f</code> in expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; new_expr = Nonlinear.add_expression(data, :(my_g($x + 1, $x)))
JuMP.Nonlinear.ExpressionIndex(3)</code></pre><p>By default, <code>Nonlinear</code> will compute the gradient of the registered operator using <code>ForwardDiff.jl</code>. (Hessian information is not supported.) Over-ride this by passing a function to compute the gradient:</p><pre><code class="language-julia-repl hljs">julia&gt; function ∇g(ret, x...)
           ret[1] = 2 * x[1] + x[2]
           ret[2] = x[1] + 2 * x[2]
           return
       end
∇g (generic function with 1 method)

julia&gt; Nonlinear.register_operator(data, :my_g2, 2, g, ∇g)</code></pre><h3 id="Nonlinear_MOI_interface"><a class="docs-heading-anchor" href="#Nonlinear_MOI_interface">MathOptInterface</a><a id="Nonlinear_MOI_interface-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear_MOI_interface" title="Permalink"></a></h3><p><code>Nonlinear</code> implements the MathOptInterface API to allow solvers to query the function and derivative information of our nonlinear model <code>data</code>. However, before we can call <a href="../../moi/reference/nonlinear/#MathOptInterface.initialize"><code>MOI.initialize</code></a>, we need to set an <a href="../../reference/nonlinear/#JuMP.Nonlinear.AbstractAutomaticDifferentiation"><code>Nonlinear.AbstractAutomaticDifferentiation</code></a>.</p><p>There are two to choose from within JuMP, although other packages may add more options by sub-typing <a href="../../reference/nonlinear/#JuMP.Nonlinear.AbstractAutomaticDifferentiation"><code>Nonlinear.AbstractAutomaticDifferentiation</code></a>:</p><ul><li><a href="../../reference/nonlinear/#JuMP.Nonlinear.Default"><code>Nonlinear.Default</code></a></li><li><a href="../../reference/nonlinear/#JuMP.Nonlinear.SparseReverseMode"><code>Nonlinear.SparseReverseMode</code></a>.</li></ul><p>If we set <a href="../../reference/nonlinear/#JuMP.Nonlinear.Default"><code>Nonlinear.Default</code></a>, then we get access to <code>:ExprGraph</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; Nonlinear.set_differentiation_backend(data, Nonlinear.Default(), [x])

julia&gt; data
NonlinearData with available features:
  * :ExprGraph</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><a href="../../reference/nonlinear/#JuMP.Nonlinear.set_differentiation_backend"><code>Nonlinear.set_differentiation_backend</code></a> requires an ordered list of the variables that are included in the model. This order corresponds to the the order of the primal decision vector <code>x</code> which is passed to the various functions in MOI&#39;s nonlinear API.</p></div></div><p>The <code>:ExprGraph</code> feature means we can call <a href="../../moi/reference/nonlinear/#MathOptInterface.objective_expr"><code>MOI.objective_expr</code></a> and <a href="../../moi/reference/nonlinear/#MathOptInterface.constraint_expr"><code>MOI.constraint_expr</code></a> to retrieve the expression graph of the problem. However, we cannot call gradient terms such as <a href="../../moi/reference/nonlinear/#MathOptInterface.eval_objective_gradient"><code>MOI.eval_objective_gradient</code></a> because <a href="../../reference/nonlinear/#JuMP.Nonlinear.Default"><code>Nonlinear.Default</code></a> does not know how to differentiate a nonlinear expression.</p><p>If, instead, we set <a href="../../reference/nonlinear/#JuMP.Nonlinear.SparseReverseMode"><code>Nonlinear.SparseReverseMode</code></a>, then we get access to <code>:Grad</code>, the gradient of the objective function, <code>:Jac</code>, the jacobian matrix of the constraints, <code>:JacVec</code>, the ability to compute Jacobian-vector products, and <code>:ExprGraph</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; Nonlinear.set_differentiation_backend(
           data,
           Nonlinear.SparseReverseMode(),
           [x],
       )

julia&gt; data
NonlinearData with available features:
  * :Grad
  * :Jac
  * :JacVec
  * :ExprGraph</code></pre><p>However, before calling anything, we need to call <a href="../../moi/reference/nonlinear/#MathOptInterface.initialize"><code>MOI.initialize</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; MOI.initialize(data, [:Grad, :Jac, :JacVec, :ExprGraph])</code></pre><p>Now we can call methods like <a href="../../moi/reference/nonlinear/#MathOptInterface.eval_objective"><code>MOI.eval_objective</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; x = [1.0]
1-element Vector{Float64}:
 1.0

julia&gt; MOI.eval_objective(data, x)
7.268073418273571</code></pre><p>and <a href="../../moi/reference/nonlinear/#MathOptInterface.eval_objective_gradient"><code>MOI.eval_objective_gradient</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; grad = [NaN]
1-element Vector{Float64}:
 NaN

julia&gt; MOI.eval_objective_gradient(data, grad, x)

julia&gt; grad
1-element Vector{Float64}:
 1.909297426825682</code></pre><h2 id="Expression-graph-representation"><a class="docs-heading-anchor" href="#Expression-graph-representation">Expression-graph representation</a><a id="Expression-graph-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Expression-graph-representation" title="Permalink"></a></h2><p><a href="../../reference/nonlinear/#JuMP.Nonlinear.NonlinearData"><code>Nonlinear.NonlinearData</code></a> stores nonlinear expressions in <a href="../../reference/nonlinear/#JuMP.Nonlinear.NonlinearExpression"><code>Nonlinear.NonlinearExpression</code></a>s. This section explains the design of the expression graph datastructure in <a href="../../reference/nonlinear/#JuMP.Nonlinear.NonlinearExpression"><code>Nonlinear.NonlinearExpression</code></a>.</p><p>Given a nonlinear function like <code>f(x) = sin(x)^2 + x</code>, the first step is to convert it into <a href="https://en.wikipedia.org/wiki/Polish_notation">Polish prefix notation</a>:</p><pre><code class="nohighlight hljs">f(x, y) = (+ (^ (sin x) 2) x)</code></pre><p>This format identifies each operator (function), as well as a list of arguments. Operators can be univariate, like <code>sin</code>, or multivariate, like <code>+</code>.</p><p>A common way of representing Polish prefix notation in code is as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; import JuMP: MOI

julia&gt; x = MOI.VariableIndex(1);

julia&gt; struct ExprNode
           op::Symbol
           children::Vector{Union{ExprNode,Float64,MOI.VariableIndex}}
       end

julia&gt; expr = ExprNode(:+, [ExprNode(:^, [ExprNode(:sin, [x]), 2.0]), x]);</code></pre><p>This datastructure follows our Polish prefix notation very closely, and we can easily identify the arguments to an operator. However, it has a significant draw-back: each node in the graph requires a <code>Vector</code>, which is heap-allocated and tracked by Julia&#39;s garbage collector (GC). For large JuMP models, we can expect to have millions of nodes in the expression graph, so this overhead quickly becomes prohibiative for computation.</p><p>An alternative is to record the expression as a linear tape:</p><pre><code class="language-julia-repl hljs">julia&gt; expr = Any[:+, 2, :^, 2, :sin, 1, x, 2.0, x]
9-element Vector{Any}:
  :+
 2
  :^
 2
  :sin
 1
  MathOptInterface.VariableIndex(1)
 2.0
  MathOptInterface.VariableIndex(1)</code></pre><p>The <code>Int</code> after each operator <code>Symbol</code> specifies the number of arguments.</p><p>This data-structure is a single vector, which resolves our problem with the GC, but each element is the abstract type, <code>Any</code>, and so any operations on it will lead to slower dynamic dispatch. It&#39;s also hard to identify the children of each operation without reading the entire tape.</p><p>To summarize, representing expression graphs in Julia has the following challenges:</p><ul><li>Nodes in the expression graph should not contain a heap-allocated object</li><li>All data-structures should be concretely typed</li><li>It should be easy to identify the children of a node</li></ul><h3 id="Sketch-of-the-design-in-Nonlinear"><a class="docs-heading-anchor" href="#Sketch-of-the-design-in-Nonlinear">Sketch of the design in Nonlinear</a><a id="Sketch-of-the-design-in-Nonlinear-1"></a><a class="docs-heading-anchor-permalink" href="#Sketch-of-the-design-in-Nonlinear" title="Permalink"></a></h3><p><code>Nonlinear</code> overcomes these problems by decomposing the datastructure into a number of different concrete-typed vectors.</p><p>First, we create vectors of the supported uni- and multivariate operators.</p><pre><code class="language-julia-repl hljs">julia&gt; const UNIVARIATE_OPERATORS = [:sin];

julia&gt; const MULTIVARIATE_OPERATORS = [:+, :^];</code></pre><p>In practice, there are many more supported operations than the ones listed here.</p><p>Second, we create an enum to represent the different types of nodes present in the expression graph:</p><pre><code class="language-julia-repl hljs">julia&gt; @enum(
           NodeType,
           NODE_CALL_MULTIVARIATE,
           NODE_CALL_UNIVARIATE,
           NODE_VARIABLE,
           NODE_VALUE,
       )</code></pre><p>In practice, there are node types other than the ones listed here.</p><p>Third, we create two concretely-typed structs as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; struct Node
           type::NodeType
           parent::Int
           index::Int
       end

julia&gt; struct NonlinearExpression
           nodes::Vector{Node}
           values::Vector{Float64}
       end</code></pre><p>For each node <code>node</code> in the <code>.nodes</code> field, if <code>node.type</code> is:</p><ul><li><code>NODE_CALL_MULTIVARIATE</code>, we look up <code>MULTIVARIATE_OPERATORS[node.index]</code> to retrieve the operator</li><li><code>NODE_CALL_UNIVARIATE</code>, we look up <code>UNIVARIATE_OPERATORS[node.index]</code> to retrieve the operator</li><li><code>NODE_VARIABLE</code>, we create <code>MOI.VariableIndex(node.index)</code></li><li><code>NODE_VALUE</code>, we look up <code>values[node.index]</code></li></ul><p>The <code>.parent</code> field of each node is the integer index of the parent node in <code>.nodes</code>. For the first node, the parent is <code>-1</code> by convention.</p><p>Therefore, we can represent our function as:</p><pre><code class="language-julia-repl hljs">julia&gt; expr = NonlinearExpression(
           [
               Node(NODE_CALL_MULTIVARIATE, 1, -1),
               Node(NODE_CALL_MULTIVARIATE, 2, 1),
               Node(NODE_CALL_UNIVARIATE, 1, 2),
               Node(NODE_VARIABLE, 1, 3),
               Node(NODE_VALUE, 1, 2),
               Node(NODE_VARIABLE, 1, 1),
           ],
           [2.0],
       );</code></pre><p>This is less readable than the other options, but does this datastructure meet our design goals?</p><p>Instead of a heap-allocated object for each node, we only have two <code>Vector</code>s for each expression, <code>nodes</code> and <code>values</code>, as well as two constant vectors for the <code>OPERATORS</code>. In addition, all fields are concretely typed, and there are no <code>Union</code> or <code>Any</code> tyypes.</p><p>For our third goal, it is not easy to identify the children of a node, but it is easy to identify the <em>parent</em> of any node. Therefore, we can use <a href="../../reference/nonlinear/#JuMP.Nonlinear.adjacency_matrix"><code>Nonlinear.adjacency_matrix</code></a> to compute a sparse matrix that maps children to their parents.</p><p>The tape is also ordered topologically, so that a reverse pass of the nodes evaluates all children nodes before their parent.</p><h3 id="The-design-in-practice"><a class="docs-heading-anchor" href="#The-design-in-practice">The design in practice</a><a id="The-design-in-practice-1"></a><a class="docs-heading-anchor-permalink" href="#The-design-in-practice" title="Permalink"></a></h3><p>In practice, <code>Node</code> and <code>NonlinearExpression</code> are exactly <a href="../../reference/nonlinear/#JuMP.Nonlinear.Node"><code>Nonlinear.Node</code></a> and <a href="../../reference/nonlinear/#JuMP.Nonlinear.NonlinearExpression"><code>Nonlinear.NonlinearExpression</code></a>. However, <a href="../../reference/nonlinear/#JuMP.Nonlinear.NodeType"><code>Nonlinear.NodeType</code></a> has more terms to account for comparison operators such as <code>:&gt;=</code> and <code>:&lt;=</code>, logic operators such as <code>:&amp;&amp;</code> and <code>:||</code>, nonlinear parameters, and nested subexpressions.</p><p>Moreover, instead of storing the operators as global constants, they are stored in <a href="../../reference/nonlinear/#JuMP.Nonlinear.OperatorRegistry"><code>Nonlinear.OperatorRegistry</code></a>, and it also stores a vector of logic operators and a vector of comparison operators. In addition to <a href="../../reference/nonlinear/#JuMP.Nonlinear.DEFAULT_UNIVARIATE_OPERATORS"><code>Nonlinear.DEFAULT_UNIVARIATE_OPERATORS</code></a> and <a href="../../reference/nonlinear/#JuMP.Nonlinear.DEFAULT_MULTIVARIATE_OPERATORS"><code>Nonlinear.DEFAULT_MULTIVARIATE_OPERATORS</code></a>, you can register user-defined functions using <a href="../../reference/nonlinear/#JuMP.Nonlinear.register_operator"><code>Nonlinear.register_operator</code></a>.</p><p><a href="../../reference/nonlinear/#JuMP.Nonlinear.NonlinearData"><code>Nonlinear.NonlinearData</code></a> is a struct that stores the <a href="../../reference/nonlinear/#JuMP.Nonlinear.OperatorRegistry"><code>Nonlinear.OperatorRegistry</code></a>, as well as a list of parameters and subexpressions in the model.</p><h2 id="ReverseAD"><a class="docs-heading-anchor" href="#ReverseAD">ReverseAD</a><a id="ReverseAD-1"></a><a class="docs-heading-anchor-permalink" href="#ReverseAD" title="Permalink"></a></h2><p><code>Nonlinear.ReverseAD</code> is a submodule for computing derivatives of the problem inside <a href="../../reference/nonlinear/#JuMP.Nonlinear.NonlinearData"><code>Nonlinear.NonlinearData</code></a> using sparse reverse-mode automatic differentiation (AD).</p><p>This section does not attempt to explain how sparse reverse-mode AD works, but instead explains why JuMP contains it&#39;s own implementation, and highlights notable differences from similar packages.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>You should not interact with <code>ReverseAD</code> directly. Instead, you should create a <a href="../../reference/nonlinear/#JuMP.Nonlinear.NonlinearData"><code>Nonlinear.NonlinearData</code></a> object, call <a href="../../reference/nonlinear/#JuMP.Nonlinear.set_differentiation_backend"><code>Nonlinear.set_differentiation_backend</code></a> with <a href="../../reference/nonlinear/#JuMP.Nonlinear.SparseReverseMode"><code>Nonlinear.SparseReverseMode</code></a>, and then query the MOI API methods.</p></div></div><h3 id="Why-another-AD-package?"><a class="docs-heading-anchor" href="#Why-another-AD-package?">Why another AD package?</a><a id="Why-another-AD-package?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-another-AD-package?" title="Permalink"></a></h3><p>The JuliaDiff organization maintains a <a href="https://juliadiff.org">list of packages</a> for doing AD in Julia. At last count, there were at least ten packages–not including <code>ReverseAD</code>–for reverse-mode AD in Julia. Given this multitude, why does JuMP maintain another implementation instead of re-using existing tooling?</p><p>Here are four reasons:</p><ul><li><strong>Scale and Sparsity:</strong> the types of functions that JuMP computes derivatives of have two key characteristics: they can be very large scale (10^5 or more functions across 10^5 or more variables) and they are very sparse. For large problems, it is common for the hessian to have <code>O(n)</code> non-zero elements instead of <code>O(n^2)</code> if it was dense. To the best of our knowledge, <code>ReverseAD</code> is the only reverse-mode AD system in Julia that handles sparsity by default. The lack of sparsity support is <em>the</em> main reason why we do no use a generic package.</li><li><strong>Limited scope:</strong> most other AD packages accept arbitrary Julia functions as input and then trace an expression graph using operator overloading. This means they must deal (or detect and ignore) with control flow, I/O, and other vagaries of Julia. In contrast, <code>ReverseAD</code> only accepts functions in the form of <a href="../../reference/nonlinear/#JuMP.Nonlinear.NonlinearExpression"><code>Nonlinear.NonlinearExpression</code></a>, which greatly limits the range of syntax that it must deal with. By reducing the scope of what we accept as input to functions relevant for mathematical optimization, we can provide a simpler implementation with various performance optimizations.</li><li><strong>Historical:</strong> <code>ReverseAD</code> started life as <a href="https://github.com/mlubin/ReverseDiffSparse.jl">ReverseDiffSparse.jl</a>, development of which begain in early 2014(!). This was well before the other packages started development. Because we had a well-tested, working AD in JuMP, there was less motivation to contribute to and explore other AD packages. The lack of historical interaction also meant that other packages were not optimized for the types of problems that JuMP is built for (i.e., large-scale sparse problems).</li><li><strong>Technical debt</strong> Prior to the introduction of <code>Nonlinear</code>, JuMP&#39;s nonlinear implementation was a confusing mix of functions and types spread across the code base and in the private <code>_Derivatives</code> submodule. This made it hard to swap the AD system for another. The main motivation for refactoring JuMP to create the <code>Nonlinear</code> submodule was to abstract the interface between JuMP and the AD system, allowing us to swap-in and test new AD systems in the future.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../extensions/">« Extensions</a><a class="docs-footer-nextpage" href="../custom_solver_binaries/">Custom binaries »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Monday 18 April 2022 10:20">Monday 18 April 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
